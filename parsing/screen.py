# Written by RedFantom, Wing Commander of Thranta Squadron,
# Daethyra, Squadron Leader of Thranta Squadron and Sprigellania, Ace of Thranta Squadron
# Thranta Squadron GSF CombatLog Parser, Copyright (C) 2016 by RedFantom, Daethyra and Sprigellania
# All additions are under the copyright of their respective authors
# For license see LICENSE
import multiprocessing as mp
import vision
import threading
import settings
import cPickle as pickle
import tempfile
from datetime import datetime
import pynput
from Queue import Queue

"""
These classes use data in a dictionary structure, dumped to a file in the temporary directory of the GSF Parser. This
dictionary contains all the data acquired by screen parsing and is stored with the following structure:

Dictionary structure:
data_dictionary[filename] = file_dictionary
file_dictionary[datetime_obj] = match_dictionary
match_dictionary[datetime_obj] = spawn_dictionary
spawn_dictionary["power_mgmt"] = power_mgmt_dict
    power_mgmt_dict[datetime_obj] = integer
spawn_dictionary["cursor_pos"] = cursor_pos_dict
    cursor_pos_dict[datetime_obj] = (x, y)
spawn_dictionary["tracking"] = tracking_dict
    tracking_dict[datetime_obj] = percentage
spawn_dictionary["clicks"] = clicks_dict
    clicks_dict[datetime_obj] = (left, right)
spawn_dictionary["keys"] = keys_dict
    keys_dict[datetime_obj] = keyname


The realtime screen parsing uses Queue objects to communicate with other parts of the program. This is required because
the screen parsing takes place in a separate process for performance optimization and itself runs several threads to
monitor mouse and keyboard activity. This only gets recorded if the user is in a match, for otherwise it might be
possible to extract keylogs of different periods, and this would impose an extremely dangerous security issue. The Queue
objects used by the ScreenParser object are the following:

data_queue:         This Queue object receives any data from the realtime file parsing that is relevant for the
                    Screen Parser object. This includes data about the file watched, the match detected, the spawn
                    detected and other information. A list of expected data:
                    - ("file", str new_file_name)           new CombatLog watched
                    - ("match", True, datetime)             new match started
                    - ("match", False, datetime)            match ended
                    - ("spawn", datetime)                   new spawn
exit_queue:         This Queue object is checked to see if the ScreenParser should stop running or not. Because this
                    is running in a separate process, one cannot just simply call __exit__, all pending operations
                    must first be completed. A list of expected data:
                    - True                                  keep running
                    - False                                 exit ASAP
_internal_queue:    This Queue object is for internal communication between the various Thread objects running in this
                    Process object. A list of expected data:
                    - ("keypress", *args)                   key pressed
                    - ("mousepress", *args)                 mouse button pressed
                    - ("mouserelease", *args)               mouse button released
                    This is not yet a complete list.
"""


class FileHandler(object):
    """
    Reads the files generated by ScreenParser for file parsing
    """
    pass


class ScreenParser(mp.Process):
    def __init__(self, data_queue, exit_queue):
        mp.Process.__init__(self)
        self.data_queue = data_queue
        self.exit_queue = exit_queue
        self._internal_queue = Queue()
        directory = tempfile.gettempdir()
        self.pickle_name = directory.replace("\\temp", "") + "\\GSF Parser\\rltdata.db"
        try:
            self.data_dictionary = pickle.load(self.pickle_name)
        except:
            self.data_dictionary = {}
        self.file = ""
        self.file_dict = {}
        self._kb_listener = pynput.keyboard.Listener(on_press=self.on_press_kb)
        self._ms_listener = pynput.mouse.Listener(on_press=self.on_press_ms, on_release=self.on_release_ms)
        self._current_match = None
        self._current_spawn = None

    def run(self):
        self._kb_listener.start()
        self._ms_listener.start()
        while True:
            if not self.exit_queue.empty():
                if not self.exit_queue.get():
                    break
            if not self.data_queue.empty():
                data = self.data_queue.get()
                if not isinstance(data, tuple):
                    raise ValueError("Unexpected data received: ", str(data))
                if data[0] == "file" and self.file is not data[1]:
                    self.data_dictionary[self.file] = self.file_dict
                    self.file = data[1]
                    self.file_dict.clear()
                if data[0] == "match" and not data[1] and not self.is_match:
                    self.is_match = False
                if data[0] == "match" and data[1] and not self.is_match:
                    pass
            screen = vision.get_cv2_screen()
            pointer_cds = vision.get_pointer_position_win32()
            power_mgmt = vision.get_power_management(screen)
            health_hull = vision.get_ship_health_hull(screen)
            health_shields_f = vision.get_ship_health_forwardshields(screen)
            health_shields_r = vision.get_ship_health_rearshields(screen)
            current_time = datetime.now()
            while not self._internal_queue.empty():
                pass

    def on_press_kb(self, *args):
        self._internal_queue.put(("keypress", args))

    def on_press_ms(self, *args):
        self._internal_queue.put("mousepress", args)

    def on_release_ms(self, *args):
        self._internal_queue.put("mouserelease", args)

    def close(self):
        self.__exit__()

    def __exit__(self):
        self.data_dictionary[self.file] = self.file_dict
        pickle.dump(self.data_dictionary, self.pickle_name)


class MouseCounter(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.gathered_date = {}

    def run(self):
        pass

